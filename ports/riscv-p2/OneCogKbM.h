// automatically generated by spin2cpp v4.0.3-beta-2313e551 on Tue Nov  5 12:09:13 2019
// command line: /home/ersmith/Parallax/spin2cpp/build/spin2cpp --p2 --ccode OneCogKbM.spin2 

#ifndef OneCogKbM_Class_Defined__
#define OneCogKbM_Class_Defined__

#include <stdint.h>

// Don't forget to set this to match the top object's MHz rate!
#define ONECOGKBM__FCLKFREQ (0x4d189680)
#define ONECOGKBM__CLKFREQ (160000000)
// ------------------------------------------------------------------------------
// P2-ES USB Host (Master) x 2 Accessory Board I/O group base pin:
// + offsets for ES-64006 Serial Host board
#define ONECOGKBM_USB_BASEPIN (16)
// ------------------------------------------------------------------------------
// #define USB_PORTB
// USB "portA" connector pin assignments (lower port):
#define ONECOGKBM_HOST_ACTIVE_LED ((ONECOGKBM_USB_BASEPIN + 4))
// USB protection enable/disable
#define ONECOGKBM_USB_PROTECT_ON ((ONECOGKBM_USB_BASEPIN + 5))
// Smart pin pair used for the USB transceiver:
// DM is "The Brain"
#define ONECOGKBM_DM ((ONECOGKBM_USB_BASEPIN + 6))
// DP is passive
#define ONECOGKBM_DP ((ONECOGKBM_USB_BASEPIN + 7))
// Long repository pin#:
#define ONECOGKBM_USB_EVENT_REPO ((ONECOGKBM_USB_BASEPIN + 8))
// Smart pin configuration for "long repository" mode:
// %MMMMM_0, P[12:10] != %101
#define ONECOGKBM_SP_REPO1_MODE ((0x2 | (1 << 16)))
#define ONECOGKBM_LED56 (56)
#define ONECOGKBM_LED57 (57)
#define ONECOGKBM_LED58 (58)
#define ONECOGKBM_LED59 (59)
#define ONECOGKBM_LED60 (60)
#define ONECOGKBM_LED61 (61)
#define ONECOGKBM_LED62 (62)
#define ONECOGKBM_LED63 (63)
#define ONECOGKBM_NO_EVENT (0)
#define ONECOGKBM_USB_ERROR (1)
#define ONECOGKBM_DEV_UNKNOWN (2)
#define ONECOGKBM_KB_READY (3)
#define ONECOGKBM_M_READY (4)
#define ONECOGKBM_KBM_READY (5)
#define ONECOGKBM_DEV_DISCONNECT (6)
#define ONECOGKBM_USB_DBG_INFO (7)
#define ONECOGKBM_M_DATA (8)
#define ONECOGKBM_MOUSE_LBTNB (0)
#define ONECOGKBM_MOUSE_RBTNB (1)
// Button bits 3..7 device specific
#define ONECOGKBM_MOUSE_CBTNB (2)
// Mouse button bitflags:
#define ONECOGKBM_MOUSE_LBTNF (((1<<ONECOGKBM_MOUSE_LBTNB)))
#define ONECOGKBM_MOUSE_RBTNF (((1<<ONECOGKBM_MOUSE_RBTNB)))
#define ONECOGKBM_MOUSE_CBTNF (((1<<ONECOGKBM_MOUSE_CBTNB)))
#define ONECOGKBM_KEY_NO_KEY (0)
#define ONECOGKBM_KEY_ERR_ROLLOVER (1)
#define ONECOGKBM_KEY_POST_FAIL (2)
#define ONECOGKBM_KEY_ERR_UNDEF (3)
// Alpha scancodes are contiguous in the lookup table, and if the caps lock key
// is toggled on, these are the only scancodes affected by it:
#define ONECOGKBM_KEY_A_A (4)
#define ONECOGKBM_KEY_Z_Z (29)
// Digit scancodes and their shifted characters:
// 1 and !
#define ONECOGKBM_KEY_1 (30)
// 0 and )
#define ONECOGKBM_KEY_0 (39)
// Keyboard return (ENTER), tab, space, etc.:
#define ONECOGKBM_KEY_ENTER (40)
#define ONECOGKBM_KEY_CAPSLK (57)
// F1..F12 keys:
#define ONECOGKBM_KEY_F1 (58)
#define ONECOGKBM_KEY_F12 (69)
// More special keys and cursor movement:
#define ONECOGKBM_KEY_PRTSCN (70)
#define ONECOGKBM_KEY_SCRLK (71)
#define ONECOGKBM_KEY_INSERT (73)
#define ONECOGKBM_KEY_DELETE (76)
#define ONECOGKBM_KEY_UP (82)
// Keypad keys:
#define ONECOGKBM_KEY_NUMLK (83)
#define ONECOGKBM_KEY_DOT_DEL (99)
#define ONECOGKBM_LED_NUMLKB (0)
#define ONECOGKBM_LED_CAPSLKB (1)
#define ONECOGKBM_LED_SCRLKB (2)
#define ONECOGKBM_LED_COMPOSEB (3)
#define ONECOGKBM_LED_KANAB (4)
#define ONECOGKBM_LED_CONST0B (5)
#define ONECOGKBM_LED_CONST1B (6)
#define ONECOGKBM_LED_CONST2B (7)
// Keyboard LED output report toggle key bitflags:
#define ONECOGKBM_LED_NUMLKF (((1<<ONECOGKBM_LED_NUMLKB)))
#define ONECOGKBM_LED_CAPSLKF (((1<<ONECOGKBM_LED_CAPSLKB)))
#define ONECOGKBM_LED_SCRLKF (((1<<ONECOGKBM_LED_SCRLKB)))
#define ONECOGKBM_LED_COMPOSEF (((1<<ONECOGKBM_LED_COMPOSEB)))
#define ONECOGKBM_LED_KANAF (((1<<ONECOGKBM_LED_KANAB)))
#define ONECOGKBM_LED_CONST0F (((1<<ONECOGKBM_LED_CONST0B)))
#define ONECOGKBM_LED_CONST1F (((1<<ONECOGKBM_LED_CONST1B)))
#define ONECOGKBM_LED_CONST2F (((1<<ONECOGKBM_LED_CONST2B)))
#define ONECOGKBM_LEFT_CTRLB (0)
#define ONECOGKBM_LEFT_SHIFTB (1)
#define ONECOGKBM_LEFT_ALTB (2)
#define ONECOGKBM_LEFT_GUIB (3)
#define ONECOGKBM_RIGHT_CTRLB (4)
#define ONECOGKBM_RIGHT_SHIFTB (5)
#define ONECOGKBM_RIGHT_ALTB (6)
#define ONECOGKBM_RIGHT_GUIB (7)
// Keyboard modifier bitflags
#define ONECOGKBM_LEFT_CTRLF (((1<<ONECOGKBM_LEFT_CTRLB)))
#define ONECOGKBM_LEFT_SHIFTF (((1<<ONECOGKBM_LEFT_SHIFTB)))
#define ONECOGKBM_LEFT_ALTF (((1<<ONECOGKBM_LEFT_ALTB)))
#define ONECOGKBM_LEFT_GUIF (((1<<ONECOGKBM_LEFT_GUIB)))
#define ONECOGKBM_RIGHT_CTRLF (((1<<ONECOGKBM_RIGHT_CTRLB)))
#define ONECOGKBM_RIGHT_SHIFTF (((1<<ONECOGKBM_RIGHT_SHIFTB)))
#define ONECOGKBM_RIGHT_ALTF (((1<<ONECOGKBM_RIGHT_ALTB)))
#define ONECOGKBM_RIGHT_GUIF (((1<<ONECOGKBM_RIGHT_GUIB)))
// Keyboard modifier flag combinations:
#define ONECOGKBM_KEY_CTRLMOD ((ONECOGKBM_LEFT_CTRLF | ONECOGKBM_RIGHT_CTRLF))
#define ONECOGKBM_KEY_SHIFTMOD ((ONECOGKBM_LEFT_SHIFTF | ONECOGKBM_RIGHT_SHIFTF))
#define ONECOGKBM_KEY_ALTMOD ((ONECOGKBM_LEFT_ALTF | ONECOGKBM_RIGHT_ALTF))
// Keyboard buffer size:
// Mouse data buffer
#define ONECOGKBM_MOUSE_BUFFMASK (15)
// Keyboard key data buffer
#define ONECOGKBM_KBD_BUFFMASK (15)
// ------------------------------------------------------------------------------
// #endregion (Shared constants)
// #region (P2 USB Smart Pins)
// ------------------------------------------------------------------------------
// Low/full speed one-cog USB host with integrated mouse/keyboard "boot
// protocol" support.
// ------------------------------------------------------------------------------
// P2-ES Evaluation Board:
//   The USB D-/D+ data lines must be an adjacent even/odd pin pair, with the
//   lower (even) pin# assigned to DM constant and the upper (odd) pin assigned
//   to the DP constant.
//   Mouse/keyboard activity is shown on the P56 LED.
//   Host status changes are posted to the mouse/keyboard data area in hub RAM.
// ------------------------------------------------------------------------------
/* 
  USB references:
  Universal Serial Bus Specification, Revision 2.0
    www.usb.org/developers/docs/usb20_docs/
  Device Class Definition for Human Interface Devices (HID), Version 1.11
    www.usb.org/developers/hidpage/

Smart pin configuration bits:
  D/# = %AAAA_BBBB_FFF_PPPPPPPPPPPPP_TT_MMMMM_0

USB smart pin modes (FPGA, test chip v1):
  %11000 = USB host, low-speed
  %11001 = USB host, full-speed
  %11010 = USB device, low-speed
  %11011 = USB device, full-speed

USB smart pin modes (scheduled for test chip v2):
  All USB smart pin modes have been consolidated to %11011.
  WXPIN is now used to set up the sub-modes and the NCO:
  bit 15 = 0 for device mode, 1 for host mode
  bit 14 = 0 for low-speed mode, 1 for full-speed mode
  bits 13..0 = NCO frequency

These modes require that two adjacent pins be configured together to form a USB pair, whose OUTs
will be overridden to control their output states. These pins must be an even/odd pair, having
only the LSB of their pin numbers different. For example: pins 0 and 1, pins 2 and 3, pins 4
and 5, etc., can form USB pairs. They can be configured via WRPIN with identical D data of
%1_110xx_0. Using D data of %0_110xx_0 will disable output drive and effectively create a USB
'sniffer'. A new WRPIN can be done to effect such a change without resetting the smart pin.

NOTE: in the current FPGA, there are no built-in 1.5k and 15k resistors, which the final silicon
smart pins will contain, so it is up to you to insert these yourself on the DP and DM lines.

The upper (odd) pin is the DP pin. This pin's IN is raised whenever the output buffer empties,
signaling that a new output byte can be written via WYPIN to the lower (even) pin. No
WXPIN/WYPIN instructions are used for this pin.

The lower (even) pin is the DM pin. This pin's IN is raised whenever a change of status occurs in
the receiver, at which point a RDPIN can be used on this pin to read the 16-bit status word.
WXPIN is used on this pin to set the NCO baud rate.

These DP/DM electrical designations can actually be switched by swapping low-speed and full-speed
modes, due to USB's mirrored line signaling.

To start USB, clear the DIR bits of the intended two pins and configure them each via WRPIN. Use
WXPIN on the lower pin to set the baud rate, which is a 16-bit fraction of the system clock. For
example, if the main clock is 80MHz and you want a 12MHz baud rate (full-speed), use
12,000,000 / 80,000,000 * $10000 = 9830. Then, set the pins' DIR bits. You are now ready to read
the receiver status via RDPIN and set output states and send packets via WYPIN, both on the
lower pin.

To affect the line states or send a packet, use WYPIN on the lower pin. Here are its D values:
 0 = output IDLE        - default state, float pins, except possible resistor(s) to 3.3V or GND
 1 = output SE0         - drive both DP and DM low
 2 = output K           - drive K state onto DP and DM (opposite)
 3 = output J           - drive J state onto DP and DM (opposite), like IDLE, but driven
 4 = output EOP         - output end-of-packet: SE0, SE0, J, then IDLE
 $80 = SOP              - output start-of-packet, then bytes, automatic EOP when buffer runs out

To send a packet, first do a 'WYPIN #$80, lowerpin'. Then, after each IN rise on the upper pin,
do a 'AKPIN upperpin', followed by a 'WYPIN byte,lowerpin' to buffer the next byte. Bits 31..8
of your data bytes are ignored, but by keeping those upper bits clear, WYPIN will be able to do
the fastest transfer to the smart pin, which takes only 4 clocks. The transmitter will automatically
send an EOP when you stop giving it bytes. To keep the output buffer from overflowing, you should
always verify that the upper pin's IN was raised after each WYPIN, before issuing another
WYPIN, even if you are just setting a state. The reason for this is that all output activity is
timed to the baud generator and even state changes must wait for the next bit period before being
implemented, at which time the output buffer empties.

There are separate state machines for transmitting and receiving. Only the baud generator is common
between them. The transmitter was just described above. Below, the receiver is detailed. Note that
the receiver receives not just input from another host/device, but all local output, as well.

At any time, a RDPIN/RQPIN can be executed on the lower pin to read the current 16-bit status of the
receiver, with the error flag going into C. The lower pin’s IN will be raised whenever a change
occurs in the receiver’s status. This will necessitate A WRPIN/WXPIN/WYPIN/RDPIN/AKPIN before IN can
be raised again, to alert of the next change in status.

NOTE that after the pin is acknowledged, it will take at least two clocks for IN to drop, before it
can be polled again:
    AKPIN    pin                   ' Acknowledge smart pin, releases IN from high
    NOP                            ' Elapse two clocks (or more)
    TESTP    pin         WC        ' IN  can now be polled again

The receiver's status bits are as follows:
 [31:16] <unused>                - $0000
 [15:8]  byte                    - last byte received
 [7]     byte toggle             - cleared on SOP, toggled on each byte received
 [6]     error                   - cleared on SOP, set on bit-unstuff error, EOP SE0 > 3 bits, or SE1
 [5]     EOP in                  - cleared on SOP or 7+ bits of J or K, set on EOP
 [4]     SOP in                  - cleared on EOP or 7+ bits of J or K, set on SOP
 [3]     steady-state indicator  - cleared on line change, set on 7+ bits of no line change
 [2]     SE0 in         (RESET)  - cleared on !SE0, set on 1+ bits of SE0
 [1]     K in           (RESUME) - cleared on !K, set on 1+ bits of K
 [0]     J in           (IDLE)   - cleared on !J, set on 1+ bits of J
The result of a RDPIN can be bit-tested for events of interest. It can also be shifted right by 8
bits to LSB-justify the last byte received and get the byte toggle bit into C, in order to determine
if you have a new byte.
 */
// ------------------------------------------------------------------------------
// USB References:
// Universal Serial Bus Specification, Revision 2.0
//   www.usb.org/developers/docs/usb20_docs/
// Device Class Definition for Human Interface Devices (HID), Version 1.11
//   www.usb.org/developers/hidpage/
// Universal Serial Bus (USB) HID Usage Tables, Version 1.12
//   www.usb.org/developers/hidpage/Hut1_12v2.pdf
// ------------------------------------------------------------------------------
// #endregion (Basics of P2 USB Smart Pins)
// #region USB host constants)
// ------------------------------------------------------------------------------
// = 4369 NCO @180MHz, 9830 @80MHz
#define ONECOGKBM__12MBPS (4915)
// = 546 NCO @180MHz, 1229 @80Mhz
#define ONECOGKBM__1_5MBPS (614)
#define ONECOGKBM_USB_V1HMODE_FS ((114 + (1 << 16)))
#define ONECOGKBM_USB_V1DMODE_FS ((118 + (1 << 16)))
#define ONECOGKBM_USB_H_FS_NCO (((3 << 14) + ONECOGKBM__12MBPS))
#define ONECOGKBM_USB_D_FS_NCO (((1 << 14) + ONECOGKBM__12MBPS))
#define ONECOGKBM_USB_V1HMODE_LS ((112 + (1 << 16)))
#define ONECOGKBM_USB_V1DMODE_LS ((116 + (1 << 16)))
#define ONECOGKBM_USB_H_LS_NCO (((2 << 14) + ONECOGKBM__1_5MBPS))
#define ONECOGKBM_USB_D_LS_NCO (((0 << 14) + ONECOGKBM__1_5MBPS))
// In P2 silicon v2 all USB smart pin modes are consolidated to %11011.
#define ONECOGKBM_USB_V2MODE ((118 + (1 << 16)))
// ------------------------------------------------------------------------------
// Time units converted to clock cycles for the given P2 Mhz clock speed
#define ONECOGKBM__1MS (160000)
#define ONECOGKBM__1US (160)
#define ONECOGKBM__100NS (16)
// Low-Speed bit period, in nanoseconds
#define ONECOGKBM_LSBTNS (0x4426c000)
// Full-Speed bit period, in nanoseconds
#define ONECOGKBM_FSBTNS (0x42a7147b)
// = 53 clocks @ 80Mhz, 80 clocks @ 120Mhz
#define ONECOGKBM__1LSBT (107)
// = 7 clocks @ 80Mhz, 10 clocks @ 120Mhz
#define ONECOGKBM__1FSBT (13)
// Time delays and intervals
// Useful USB constants and wait intervals:
// Connect/disconnect verification delay
#define ONECOGKBM_CONNECT_WAIT ((ONECOGKBM__1MS * 250))
// Host reset state hold time
#define ONECOGKBM_RESET_HOLD ((ONECOGKBM__1MS * 15))
// Maximum retries before retiring a transfer
#define ONECOGKBM_XFER_RETRIES (12)
// Maximum retries before retiring a transaction
#define ONECOGKBM_TXN_RETRIES (12)
// Unlimited NAK retries
#define ONECOGKBM_NAK_NOLIMIT (0)
// Control transfer IN-NAK retry limit (0 = unlimited)
#define ONECOGKBM_IN_NAK_RETRIES (50000)
// Control transfer OUT-NAK retry limit (0 = unlimited)
#define ONECOGKBM_OUT_NAK_RETRIES (50000)
// Transfer retry wait timespan
#define ONECOGKBM_XFER_WAIT ((ONECOGKBM__1MS * 5))
// Standard Device request maximum timeout periods:
// Non-specific maximum timout period
#define ONECOGKBM_TO_STANDARD ((ONECOGKBM__1MS * 5000))
// Standard Device requests with a data stage
#define ONECOGKBM_TO_DATA ((ONECOGKBM__1MS * 500))
// Standard Device requests without a data stage
#define ONECOGKBM_TO_NODATA ((ONECOGKBM__1MS * 50))
// Device SetAddress() command processing maximum
#define ONECOGKBM_TO_SETADDR ((ONECOGKBM__1MS * 50))
// Device SetAddress() period allowed to change its address before next request sent
#define ONECOGKBM_TO_CHGADDR ((ONECOGKBM__1MS * 2))
// ------------------------------------------------------------------------------
// Low-Speed inter-packet delay, in bit periods (Section 7.1.18). For the host,
// the range is a minimum of two bit periods and a maximum of 7.5 bit periods:
// ------------------------------------------------------------------------------
// Range @180MHz: 240 to 901 clocks (1.334us to 5.003us)
#define ONECOGKBM_IP_DELAY_LS (427)
// Range @180MHz: 30 to 112  clocks (0.166us to 0.623us)
#define ONECOGKBM_IP_DELAY_FS (53)
// ------------------------------------------------------------------------------
// End-to-end signal delay, in bit periods (Section 7.1.19), measured at the
// data pins of the device from the SE0-to-J transition at the end of the EOP.
// For example, when a device transmits the data for an IN transaction, it will
// wait at least 16 bit periods for the host handshake response, but no more
// than 18 bit periods:
//   Low-Speed:  10.672us..12.006us (@80MHz: 853.8 to 960.5 clocks).
//   Full-Speed: 1.238us..1.494us (@80MHz: 106.2 to 119.5 clocks).
// When the host transmits data e.g. an OUT transaction, it must wait at least
// 18 bit periods before it will timeout the response and start a new transaction.
// ------------------------------------------------------------------------------
#define ONECOGKBM_TAT_WAIT_LS (2348)
#define ONECOGKBM_TAT_WAIT_FS (374)
// ------------------------------------------------------------------------------
// Interrupt service routine timespans for 1ms interval frame generation.
// Target resolution is 1.00ms +/- 0.0005ms. At full-speed, a numbered
// start-of-frame packet is issued. At low-speed, a single EOP is issued as a
// "keep-alive" strobe to prevent a device from entering suspend mode.
// ------------------------------------------------------------------------------
// All USB transactions must be started within this timespan
#define ONECOGKBM_TXN_OK_LS (((ONECOGKBM__1US * 667) - 6))
// Low-speed needs ~33% bandwidth per max packet of 8 bytes
#define ONECOGKBM_NO_TXN_LS (((ONECOGKBM__1US * 333) - 7))
// Full-speed needs ~10% bandwidth per max packet of 64 bytes
#define ONECOGKBM_TXN_OK_FS (((ONECOGKBM__1US * 825) - 6))
#define ONECOGKBM_NO_TXN_FS (((ONECOGKBM__1US * 175) - 7))
// Non-USB related time intervals:
// LED-blinking heartbeat interval
#define ONECOGKBM_PULSE_TIME ((ONECOGKBM__1MS * 750))
// PID tokens
// ------------------------------------------------------------------------------
// Token packet format.
// ------------------------------------------------------------------------------
//                       CRC5  ENDP ADDRESS PID
#define ONECOGKBM_CRC_MASK (16252928)
#define ONECOGKBM_EP_MASK (491520)
#define ONECOGKBM_ADDR_MASK (32512)
#define ONECOGKBM_EP_ADDR_MASK (524287)
// CRC5 = $02 for addr zero, ep zero
#define ONECOGKBM_EP_ADDR_ZERO (1048576)
// ------------------------------------------------------------------------------
// Packet Identifier Bytes (PID). Notice that the first two LSBits are
// identical for each group.
// ------------------------------------------------------------------------------
// Token:
// $e1
#define ONECOGKBM_PID_OUT (225)
// $69
#define ONECOGKBM_PID_IN (105)
// $a5
#define ONECOGKBM_PID_SOF (165)
// $2d
#define ONECOGKBM_PID_SETUP (45)
// Data:
// $c3
#define ONECOGKBM_PID_DATA0 (195)
// $4b
#define ONECOGKBM_PID_DATA1 (75)
// $87
#define ONECOGKBM_PID_DATA2 (135)
// $0f
#define ONECOGKBM_PID_MDATA (15)
// Handshake:
// $d2
#define ONECOGKBM_PID_ACK (210)
// $5a
#define ONECOGKBM_PID_NAK (90)
// $1e
#define ONECOGKBM_PID_STALL (30)
// $96
#define ONECOGKBM_PID_NYET (150)
// Special:
// $3c
#define ONECOGKBM_PID_PRE (60)
// $3c
#define ONECOGKBM_PID_ERR (60)
// $78
#define ONECOGKBM_PID_SPLIT (120)
// $b4
#define ONECOGKBM_PID_PING (180)
// $f0
#define ONECOGKBM_PID_RESVD (240)
// Tx, rx and host related constants
// USB transmitter WYPIN D line state options:
#define ONECOGKBM_OUT_IDLE (0)
#define ONECOGKBM_OUT_SE0 (1)
#define ONECOGKBM_OUT_K (2)
#define ONECOGKBM_OUT_J (3)
#define ONECOGKBM_OUT_EOP (4)
#define ONECOGKBM_OUT_SOP (128)
#define ONECOGKBM_J_IDLEB (0)
#define ONECOGKBM_K_RESUMEB (1)
#define ONECOGKBM_SE0_RESETB (2)
#define ONECOGKBM_SE1_BADB (3)
#define ONECOGKBM_SOPB (4)
#define ONECOGKBM_EOPB (5)
#define ONECOGKBM_BUS_ERRB (6)
#define ONECOGKBM_BYTE_TGLB (7)
// USB receiver RDPIN status bitflags:
#define ONECOGKBM_J_IDLEF (((1<<ONECOGKBM_J_IDLEB)))
#define ONECOGKBM_K_RESUMEF (((1<<ONECOGKBM_K_RESUMEB)))
#define ONECOGKBM_SE0_RESETF (((1<<ONECOGKBM_SE0_RESETB)))
#define ONECOGKBM_SE1_BADF (((1<<ONECOGKBM_SE1_BADB)))
#define ONECOGKBM_SOPF (((1<<ONECOGKBM_SOPB)))
#define ONECOGKBM_EOPF (((1<<ONECOGKBM_EOPB)))
#define ONECOGKBM_BUS_ERRF (((1<<ONECOGKBM_BUS_ERRB)))
#define ONECOGKBM_BYTE_TGLF (((1<<ONECOGKBM_BYTE_TGLB)))
// USB CRC constants:
// USB5 polynomial is reflected when calculating CRC
#define ONECOGKBM_USB5_POLY ((__builtin_propeller_rev(5, 32 - 5)))
// Expected CRC5 residual value when checking received data
#define ONECOGKBM_USB5_RESIDUAL ((__builtin_propeller_rev(12, 32 - 5)))
// USB16 polynomial is reflected when calculating CRC
#define ONECOGKBM_USB16_POLY ((__builtin_propeller_rev(32773, 32 - 16)))
// Expected CRC16 residual value when checking received data
#define ONECOGKBM_USB16_RESIDUAL ((__builtin_propeller_rev(32781, 32 - 16)))
#define ONECOGKBM_USB_SPEED_UNKNOWN (0)
#define ONECOGKBM_USB_SPEED_LOW (1)
#define ONECOGKBM_USB_SPEED_FULL (2)
#define ONECOGKBM_ERR_NONE (0)
#define ONECOGKBM_ERR_URX (1)
#define ONECOGKBM_ERR_SE1 (2)
#define ONECOGKBM_ERR_PACKET (3)
#define ONECOGKBM_ERR_TAT (4)
#define ONECOGKBM_ERR_TXN_RETRY (5)
#define ONECOGKBM_ERR_XFER_RETRY (6)
#define ONECOGKBM_ERR_NAK (7)
#define ONECOGKBM_ERR_ACK_RETRY (8)
#define ONECOGKBM_ERR_EMPTY_PKT (9)
#define ONECOGKBM_ERR_RX_CRC (10)
#define ONECOGKBM_ERR_DATAX_SYNC (11)
#define ONECOGKBM_ERR_CONFIG_FAIL (12)
#define ONECOGKBM_ERR_END (13)
// Debug stuff:
// Handy byte sequence for hex search in .obj files
#define ONECOGKBM_DBG_FEEDBEEF (-272699906)
// End of cog/lut code marker
#define ONECOGKBM_DBG_C0DEDEAD (-1377902912)
// End of data marker
#define ONECOGKBM_DBG_DADADEAD (-1377903910)
#define ONECOGKBM_IDLEB (0)
#define ONECOGKBM_CONNECTEDB (1)
#define ONECOGKBM_LOW_SPEEDB (2)
#define ONECOGKBM_DATAX_TGLB (3)
#define ONECOGKBM_TXN_LIMITB (4)
#define ONECOGKBM_DWNSTRM_HUBB (8)
// Host status bitflags. Unless otherwise noted, bit states are active high:
// Set when USB in idle state
#define ONECOGKBM_IDLEF (((1<<ONECOGKBM_IDLEB)))
// USB device connected
#define ONECOGKBM_CONNECTEDF (((1<<ONECOGKBM_CONNECTEDB)))
// Low-speed device connected, clear if full-speed
#define ONECOGKBM_LOW_SPEEDF (((1<<ONECOGKBM_LOW_SPEEDB)))
// Cleared if sending DATA0 packet, set if sending DATA1 packet
#define ONECOGKBM_DATAX_TGLF (((1<<ONECOGKBM_DATAX_TGLB)))
// No-go area to prevent transactions from spanning frame boundary
#define ONECOGKBM_TXN_LIMITF (((1<<ONECOGKBM_TXN_LIMITB)))
//       EOPF         = |< EOPB                  ' Same bit position as the USB receiver RDPIN constant defined above
//       BUS_ERRF     = |< BUS_ERRB              ' Same bit position as the USB receiver RDPIN constant defined above
//       BYTE_TGLF    = |< BYTE_TGLB             ' Same bit position as the USB receiver RDPIN constant defined above
// Not yet implemented
#define ONECOGKBM_DWNSTRM_HUBF (((1<<ONECOGKBM_DWNSTRM_HUBB)))
// LUT allocation:
// ------------------------------------------------------------------------------
#define ONECOGKBM_HLUT_BASE (104)
#define ONECOGKBM_HLUT_TOP (511)
// ------------------------------------------------------------------------------
// Keyboard and mouse constants:
// ------------------------------------------------------------------------------
// Keyboard interrupt endpoint poll interval and auto-repeat timing. Since the
// interrupt IN transactions are executed on a timed basis, use that to
// calculate auto-repeat initial delay and repeat rate.
// ------------------------------------------------------------------------------
// Interrupt IN txn timespan
#define ONECOGKBM_KBD_POLL_INTERVAL ((ONECOGKBM__1MS * 8))
// 62 * 8ms = 496ms initial delay
#define ONECOGKBM_KBD_REPEAT_DELAY (62)
// 5 * 8ms = 40ms repeat rate
#define ONECOGKBM_KBD_REPEAT_RATE (5)
// ------------------------------------------------------------------------------
// Mouse interrupt endpoint poll interval:
// ------------------------------------------------------------------------------
// Interrupt IN txn timespan
#define ONECOGKBM_MOUSE_POLL_INTERVAL ((ONECOGKBM__1MS * 8))
// USER_LED feedback blink delay uses the NAK count
#define ONECOGKBM_MOUSE_NAK_DELAY (62)
// ------------------------------------------------------------------------------
// Startup parameter count:
#define ONECOGKBM_START_PARM_COUNT (3)
// ------------------------------------------------------------------------------
// USB References:
// Universal Serial Bus Specification, Revision 2.0
//   www.usb.org/developers/docs/usb20_docs/
// Device Class Definition for Human Interface Devices (HID), Version 1.11
//   www.usb.org/developers/hidpage/
// ------------------------------------------------------------------------------
// SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
// Use TYPE_STANDARD for all USB Standard Device Request codes.
// ------------------------------------------------------------------------------
// D7 Data direction  | D6:5 Type    | D4:0 Recipient
// ------------------------------------------------------------------------------
// 0 - Host-to-device | 0 = Standard | 0 = Device
// 1 - Device-to-host | 1 = Class    | 1 = Interface
//                    | 2 = Vendor   | 2 = Endpoint
//                    | 3 = Reserved | 3 = Other
//                    |              | 4 -31 = Reserved
// ------------------------------------------------------------------------------
#define ONECOGKBM_DIR_HOST_TO_DEV ((0 << 7))
// D7 Data direction
#define ONECOGKBM_DIR_DEV_TO_HOST ((1 << 7))
// D6:D5 Type (use Standard for all USB Standard Device Requests
#define ONECOGKBM_TYPE_STANDARD ((0 << 5))
#define ONECOGKBM_TYPE_CLASS ((1 << 5))
#define ONECOGKBM_TYPE_VENDOR ((2 << 5))
#define ONECOGKBM_TYPE_RESERVED ((3 << 5))
// D4..D0 Recipient
#define ONECOGKBM_RECIP_DEVICE (0)
#define ONECOGKBM_RECIP_INTERFACE (1)
#define ONECOGKBM_RECIP_ENDPOINT (2)
#define ONECOGKBM_RECIP_OTHER (3)
#define ONECOGKBM_REQ_GET_STATUS (0)
#define ONECOGKBM_REQ_CLEAR_FEATURE (1)
#define ONECOGKBM_REQ_RESERVED_1 (2)
#define ONECOGKBM_REQ_SET_FEATURE (3)
#define ONECOGKBM_REQ_RESERVED2 (4)
#define ONECOGKBM_REQ_SET_ADDR (5)
#define ONECOGKBM_REQ_GET_DESC (6)
#define ONECOGKBM_REQ_SET_DESC (7)
#define ONECOGKBM_REQ_GET_CONFIG (8)
#define ONECOGKBM_REQ_SET_CONFIG (9)
#define ONECOGKBM_REQ_GET_INTF (10)
#define ONECOGKBM_REQ_SET_INTF (11)
#define ONECOGKBM_REQ_SYNC_FRAME (12)
#define ONECOGKBM_TYPE_DEVICE (1)
#define ONECOGKBM_TYPE_CONFIG (2)
#define ONECOGKBM_TYPE_STRING (3)
#define ONECOGKBM_TYPE_INTERFACE (4)
#define ONECOGKBM_TYPE_ENDPOINT (5)
#define ONECOGKBM_TYPE_QUALIFIER (6)
#define ONECOGKBM_TYPE_OTHER_SPEED (7)
#define ONECOGKBM_TYPE_INTERFACE_PWR (8)
#define ONECOGKBM_TYPE_OTG (9)
#define ONECOGKBM_CLASS_INFO_INTF (0)
#define ONECOGKBM_CLASS_AUDIO (1)
#define ONECOGKBM_CLASS_COMM (2)
#define ONECOGKBM_CLASS_HID (3)
#define ONECOGKBM_CLASS_UNDEF0 (4)
#define ONECOGKBM_CLASS_PHYSICAL (5)
#define ONECOGKBM_CLASS_IMAGE (6)
#define ONECOGKBM_CLASS_PRINTER (7)
#define ONECOGKBM_CLASS_MASS_STORAGE (8)
#define ONECOGKBM_CLASS_HUB (9)
#define ONECOGKBM_CLASS_CDC_DATA (10)
#define ONECOGKBM_CLASS_SMARTCARD (11)
#define ONECOGKBM_CLASS_UNDEF1 (12)
#define ONECOGKBM_CLASS_CONT_SECURITY (13)
#define ONECOGKBM_CLASS_VIDEO (14)
#define ONECOGKBM_CLASS_HEALTH (15)
#define ONECOGKBM_CLASS_AUDIO_VIDEO (16)
#define ONECOGKBM_CLASS_BILLBOARD (17)
#define ONECOGKBM_CLASS_TYPE_C_BRIDGE (18)
#define ONECOGKBM_CLASS_DIAGNOSTIC_DEV (220)
#define ONECOGKBM_CLASS_WIRELESS_CTRL (224)
#define ONECOGKBM_CLASS_MISCELLANEOUS (239)
#define ONECOGKBM_CLASS_APP_SPECIFIC (254)
#define ONECOGKBM_CLASS_VENDOR_SPECIFIC (255)
#define ONECOGKBM_HID_GET_REPORT (1)
#define ONECOGKBM_HID_GET_IDLE (2)
#define ONECOGKBM_HID_GET_PROTO (3)
// $04 - $08 reserved
#define ONECOGKBM_HID_SET_REPORT (9)
#define ONECOGKBM_HID_SET_IDLE (10)
#define ONECOGKBM_HID_SET_PROTO (11)
#define ONECOGKBM_TYPE_HID (33)
#define ONECOGKBM_TYPE_REPORT (34)
// HID types $24 - $2f are reserved
#define ONECOGKBM_TYPE_PHYSICAL (35)
#define ONECOGKBM_TYPE_INPUT (1)
#define ONECOGKBM_TYPE_OUTPUT (2)
// $04 - $ff are reserved
#define ONECOGKBM_TYPE_FEATURE (3)
#define ONECOGKBM_SUBCLASS_INTF_NONE (0)
#define ONECOGKBM_SUBCLASS_INTF_BOOT (1)
#define ONECOGKBM_INTF_PROTO_NONE (0)
#define ONECOGKBM_INTF_PROTO_KBD (1)
#define ONECOGKBM_INTF_PROTO_MOUSE (2)
#define ONECOGKBM_BOOT_PROTOCOL (0)
#define ONECOGKBM_REPORT_PROTOCOL (1)
// ------------------------------------------------------------------------------
// Other HID buffer lengths:
// ------------------------------------------------------------------------------
// We have this many HID report buffers
#define ONECOGKBM_MAX_HID_REPTS (4)
// HID reports can be quite large
#define ONECOGKBM_REPT_BUFF_LEN (1024)
// Struct is wLength, bData[REPT_BUFF_LEN]
#define ONECOGKBM_REPT_STRUCT_LEN ((ONECOGKBM_REPT_BUFF_LEN + 2))
// LangID array buffer (in bytes)
#define ONECOGKBM_LANG_BUFF_LEN (128)
// Unicode string buffer (in bytes)
#define ONECOGKBM_USTR_BUFF_LEN (128)
// ------------------------------------------------------------------------------
// USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
// ------------------------------------------------------------------------------
// English (United States)
#define ONECOGKBM_LANG_ENG_US (1033)
// Set your default langID here
#define ONECOGKBM_LOCAL_LANGID (ONECOGKBM_LANG_ENG_US)
// ------------------------------------------------------------------------------
// SETUP structure member offsets.
// NOTE: These offsets are defined in terms of the structure member's data type,
//       to take advantage of PTRA/B scaled indexing, e.g.:
//         RDBYTE D,   PTRA[bRequest]
//         WRWORD D/#, PTRA[wLength]
// ------------------------------------------------------------------------------
#define ONECOGKBM_BMREQUESTTYPE (0)
#define ONECOGKBM_BREQUEST (1)
#define ONECOGKBM_WVALUE (1)
#define ONECOGKBM_WINDEX (2)
#define ONECOGKBM_WLENGTH (3)
// SETUP bmRequestType combinations:
/* 
        HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
        DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
        HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
        HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
 */
// ------------------------------------------------------------------------------
// Standard USB descriptor structure sizes in bytes. The values defined are the
// minimum size of the descriptor:
// ------------------------------------------------------------------------------
#define ONECOGKBM_SETUP_TXN_LEN (8)
#define ONECOGKBM_DEV_DESC_LEN (18)
#define ONECOGKBM_CON_DESC_LEN (9)
#define ONECOGKBM_INTF_DESC_LEN (9)
#define ONECOGKBM_ENDP_DESC_LEN (7)
#define ONECOGKBM_STR0_DESC_LEN (4)
#define ONECOGKBM_USTR_DESC_LEN (4)
// ------------------------------------------------------------------------------
// Other USB-related buffer sizes:
// ------------------------------------------------------------------------------
// USB receiver scratch buffer
#define ONECOGKBM_URX_BUFF_LEN (128)
// Entire configuration descriptor chain
#define ONECOGKBM_CON_BUFF_LEN (256)
// ------------------------------------------------------------------------------
// CON_bmAttrs member bit positions:
// ------------------------------------------------------------------------------
// Reserved (should always be one)
#define ONECOGKBM_ATTR_RESVB (7)
// Device Self-Powered
#define ONECOGKBM_ATTR_SELF_PWRB (6)
// Supports remote wakeup
#define ONECOGKBM_ATTR_RMT_WAKEB (5)
//       bmAttributes bits 4..0 reserved and reset to zero
// ------------------------------------------------------------------------------
// Standard USB descriptor struct member offset and member size, in bytes. Note
// that the DESC_bLength and DESC_bDescType members are defined in all of the
// descriptors (including HID) at the offsets shown.
// ------------------+
// !!! IMPORTANT !!!|
// ------------------+
// All standard descriptor member offsets are defined in bytes, so if you want
// to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
// syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
// e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
//       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
// If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
// must be very careful...
// ------------------------------------------------------------------------------
//       Member          Offset  Size    Value           Description
// ------------------------------------------------------------------------------
// 1     Number          Minimum size of this descriptor in bytes
#define ONECOGKBM_DESC_BLENGTH (0)
// 1     Constant        TYPE_DEVICE
#define ONECOGKBM_DESC_BDESCTYPE (1)
// Device Descriptor (Section 9.6.1, Table 9-8):
// 2     BCD             e.g., 2.10 is $0210
#define ONECOGKBM_DEV_BCDUSB (2)
// 1     Class           Class code assigned by USB-IF.
#define ONECOGKBM_DEV_BDEVCLASS (4)
// 1     SubClass        SubClass Code assigned by USB-IF.
#define ONECOGKBM_DEV_BDEVSUBCLASS (5)
// 1     Protocol        Protocol Code assigned by USB-IF.
#define ONECOGKBM_DEV_BPROTOCOL (6)
// 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
#define ONECOGKBM_DEV_BMAXPKTSIZE0 (7)
// 2     ID              Vendor ID - must be obtained from USB-IF.
#define ONECOGKBM_DEV_IDVENDOR (8)
// 2     ID              PRoduct ID - must be obtained from USB-IF.
#define ONECOGKBM_DEV_IDPRODUCT (10)
// 2     BCD             Device release number in BCD.
#define ONECOGKBM_DEV_BCDDEVICE (12)
// 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
#define ONECOGKBM_DEV_IMFG (14)
// 1     Index           Index of string descriptor describing product - set to zero if no string.
#define ONECOGKBM_DEV_IPRODUCT (15)
// 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
#define ONECOGKBM_DEV_ISERIALNUM (16)
// 1     Number          Number of possible configurations.
#define ONECOGKBM_DEV_INUMCONFIGS (17)
// Configuration Descriptor (Section 9.6.3, Table 9-10):
//       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
//       DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
// 2     Number          See Section 9.6.3, Table 9-10.
#define ONECOGKBM_CON_WTOTALLEN (2)
// 1     Number          Number of interfaces supported by this configuration.
#define ONECOGKBM_CON_BNUMINTF (4)
// 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
#define ONECOGKBM_CON_BCONFIGVAL (5)
// 1     Index           Index of string descriptor describing this configuration.
#define ONECOGKBM_CON_ICONFIG (6)
// 1     Bitmap          See Table 9-10.
#define ONECOGKBM_CON_BMATTRS (7)
// 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
#define ONECOGKBM_CON_BMAXPOWER (8)
// Interface Descriptor (Section 9.6.5, Table 9-12):
//       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
//       DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
// 1     Number          See Table 9-12.
#define ONECOGKBM_INTF_BINTFNUM (2)
// 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
#define ONECOGKBM_INTF_BALTSETTING (3)
// 1     Number          See Table 9-12.
#define ONECOGKBM_INTF_BNUMENDPTS (4)
// 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
#define ONECOGKBM_INTF_BINTFCLASS (5)
// 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
#define ONECOGKBM_INTF_BSUBCLASS (6)
//                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
//                       reserved for assignment by the USB-IF.
// 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
#define ONECOGKBM_INTF_BPROTOCOL (7)
//                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
//                       vendor-specific protocol for this interface.
// 1     Index           Index of string descriptor describing this interface.
#define ONECOGKBM_INTF_IINTERFACE (8)
// Endpoint Descriptor (Section 9.6.6, Table 9-13):
//       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
//       DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
// 1     Endpoint        See table 9-13.
#define ONECOGKBM_ENDP_BADDRESS (2)
// 1     Bitmap
#define ONECOGKBM_ENDP_BMATTRS (3)
// 2     Number
#define ONECOGKBM_ENDP_WMAXPKTSIZE (4)
// 1     Number
#define ONECOGKBM_ENDP_BINTERVAL (6)
// String Descriptor Zero (Section 9.6.7, Table 9-15):
//       DESC_bLength     = 0    ' 1     N + 2
//       DESC_bDescType   = 1    ' 1     Constant
// N     LangID[(N - 2) / 2]
#define ONECOGKBM_STR0_WLANGID (2)
// Unicode String Descriptor (Section 9.6.7, Table 9-16):
//       DESC_bLength     = 0    ' 1     N + 2
//       DESC_bDescType   = 1    ' 1     Constant
// N     wString[(N - 2) / 2]
#define ONECOGKBM_USTR_WSTRING (2)
// #region Descriptors required by this device class
// ------------------------------------------------------------------------------
// HID Descriptor (Section 6.2.1)
// ------------------------------------------------------------------------------
//       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
//       DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
// 2     BCD             e.g., 1.10 is $0110
#define ONECOGKBM_HID_BCDHID (2)
// 1     Number          Hardware target country
#define ONECOGKBM_HID_BCOUNTRYCODE (4)
// 1     Number          Number of HID class descriptors to follow, always at least one.
#define ONECOGKBM_HID_BNUMDESC (5)
// 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
#define ONECOGKBM_HID_BDESCTYPE (6)
// 2     Number          Total length of descriptor(s).
#define ONECOGKBM_HID_WDESCLENGTH (7)
// Keyboard and mouse report data buffer lengths (boot protocol):
// CapsLock, NumLock and ScrollLock status bits
#define ONECOGKBM_KBD_OUT_RPT_LEN (1)
// Maximum keyboard boot protocol IN data packet size
#define ONECOGKBM_KBD_IN_RPT_LEN (8)
// Maximum mouse boot protocol IN data packet size
#define ONECOGKBM_MOUSE_RPT_LEN (8)
// LED to blink at host/driver fatal error:
#define ONECOGKBM_HOST_ERROR_LED (ONECOGKBM_LED56)
// ------------------------------------------------------------------------------
// LED to show USB activity:
//        KBM_ACTIVE_LED = LED56
// P2-ES board user LEDs tied to pins:
// ------------------------------------------------------------------------------
// A simple event system using a smart pin configured in "long repository" mode.
// The USB_EVENT_REPO pin defined above is used to allow the USB cog to signal
// the client that a particular event has occurred. The client must poll this
// smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main" loop
// and have a related spin function to handle the event.
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// Reference: "Device Class Definition for Human Interace Devices (HID), v1.11,
// Appendix B: Boot Interface".
// ------------------------------------------------------------------------------
// Boot protocol mouse constants:
// ------------------------------------------------------------------------------
// Mouse button bit assignments (left, right, center):
// ------------------------------------------------------------------------------
// USB HID Keyboard/Keypad Page (0x07). The scancodes below are indexes into
// the scancode->character/function look-up table.
// ------------------------------------------------------------------------------
// USB boot protocol key scancode constants. IMPORTANT: these constants are the
// keyboard scan codes per USB HID specification 1.11. The keypress value that
// the USB cog writes to the kbd_keypress location will be a 7-bit ASCII value
// if the key scancode represents an ASCII character e.g., TAB->$09,
// BACKSPACE->$08, SPACE->$20, DELETE->$7f, etc. If there is NOT an ACSII match,
// the keypress value will be the same as the key's HID scan code. In those
// cases, it is up to the client program to implement the action required for
// that key.
// ------------------------------------------------------------------------------
// First four entries in the key lookup table are info/error indicators:
// ------------------------------------------------------------------------------
// Keyboard LED output report toggle key bit postions:
// Keyboard modifier key bit positions:
// USB receiver RDPIN status bit positions:
// Host->class driver USB connect speed:
// Protocol error codes:
// Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
//       RECIP 4 - 31 = Reserved
// ------------------------------------------------------------------------------
// Standard Device Request codes (Section 9.4, Table 9-4):
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// Standard descriptor types (Section 9.4, Table 9-5):
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
// ------------------------------------------------------------------------------
// HID Descriptor types:
// ------------------------------------------------------------------------------
// HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// HID Interface SubClasses:
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// HID Protocol codes:
// ------------------------------------------------------------------------------

typedef struct OneCogKbM {
  volatile int32_t 	usbcog;
// Paramter block start address passed to the USB cog via COGNEW parameter
  volatile int32_t 	itemaddr;
  volatile int32_t 	itemcount;
// Contiguous cog/lut register/cell values
  volatile int32_t 	datavals[32];
// Parameter block end
  volatile int32_t 	hw_rev;
} OneCogKbM;

  int32_t OneCogKbM_start(int32_t status);
  int32_t OneCogKbM_mouse(void);
  int32_t OneCogKbM_key(void);
#endif
